#include "map_data.hpp"

#include <cstdio>
#include <cstdlib>
#include <iostream>

mdata::MapData::MapData(void) {

    mDataAvaliable = false;

    // In future will check if there is up to date MapData and load it if that is the case. For now just generates data from scratch.
    /*if(MapData has already been built and was not modified)
    Just load
    else*/
    fprintf(stdout, "> No map data has been found or prov_it is not up to date! New map data will now be generated...\n");
    fprintf(stdout, ">> Generating map...\n");
    fflush(stdout);

    // Creates an instance of the MapGenerator and attempts to generate the map data.
    MapGenerator generator;
    if(!(mDataAvaliable = generator.generateMapData())) { 
        fprintf(stderr, "> Failed to generate map data!\n"); 
        return;
    } else {
        fprintf(stdout, "> Map data generated successfully!\n");
        fflush(stdout);

        mDataAvaliable = true;
    }

}

// Generates map data from image and text files in the ./map directory
bool mdata::MapGenerator::generateMapData() {

    if(!loadNecessaryFiles()) { 
        fprintf(stderr, ">> Failed to load all necessary files!\n"); 
        return false;
    } else {
        fprintf(stdout, ">> Necessary files loaded successfully!\n");
        fflush(stdout);
    }

    fprintf(stdout, ">> Generating provinces...!\n");
    fflush(stdout);

    sf::Vector2u map_size = provinceMap.getSize();

    std::set<std::pair<unsigned, unsigned>> adjacencies;

    std::map<unsigned,mdata::Province>::iterator prov_it;

    // Generates provinces that are in the first line of the map.
    for(unsigned x = 0; x < map_size.x; x++) {

        // Verifies if a province with the color of the current pixel has already been generated and gets an iterator to it.
        prov_it = provincesInGeneration.find(generateIdFromColor(provinceMap.getPixel(x,0)));

        // If an iterator is found just update province edges.
        if (prov_it != provincesInGeneration.end())
            updateEdgeCoordinates(x,0,prov_it);
        else // If an iterator is not found a province with this color doesn't exist and therefore needs to be generated.
            createProvince(x,0);

    }

    sf::Color cur_color;
    sf::Color next_color;

    std::map<unsigned,mdata::Province>::iterator next_prov_it;

    // Verifies all pixels of the image.
    for(unsigned y = 0; y < map_size.y; y++) {
        for(unsigned x = 0; x < map_size.x; x++) {

            cur_color = provinceMap.getPixel(x,y);

            // Check the pixel to the right of the current pixel, 
            if(x + 1 < map_size.x) {

                next_color = provinceMap.getPixel(x + 1, y);


                /* If the color of both pixels is te same theres is nothing that needs to be done.
                   Also don't do anything if the color of the other pixel is black, the color black is reserved if for some reason you need to create a
                   "void" spot in the map. */
                if(cur_color != next_color && next_color != sf::Color::Black) {
                    
                    // Finds an iterator to the current province.
                    prov_it = provincesInGeneration.find(generateIdFromColor(cur_color));

                    // Update the edge coordinates for the current province.
                    updateEdgeCoordinates(x, y, prov_it);

                    // Finds a iterator to the other province.
                    // OBS: provinces on the same line will always already have being generated by the line above (SEE BELOW).
                    // That is also the reason the first line is generated separately.
                    next_prov_it = provincesInGeneration.find(generateIdFromColor(next_color));

                    // Add an adjacency between those two provinces. Because it is a std::set duplicates will be ignored.
                    // Always add the province with the smallest id first to guarantee there can't be a duplicate with just the values reversed.
                    if((*prov_it).second.numeric_id < (*next_prov_it).second.numeric_id)
                        adjacencies.insert(std::make_pair((*prov_it).second.numeric_id,(*next_prov_it).second.numeric_id));
                    else
                        adjacencies.insert(std::make_pair((*next_prov_it).second.numeric_id,(*prov_it).second.numeric_id));

                    // Update the edge coordinates for the other province.
                    updateEdgeCoordinates(x, y + 1, next_prov_it);

                }
            }

            // Check the pixel below the current pixel.
            if(y + 1 < map_size.y) {

                next_color = provinceMap.getPixel(x, y + 1);

                if(cur_color != next_color && next_color != sf::Color::Black) {

                    
                    prov_it = provincesInGeneration.find(generateIdFromColor(cur_color));

                    updateEdgeCoordinates(x, y, prov_it);

                    // Tries to find an iterator to the other province.
                    next_prov_it = provincesInGeneration.find(generateIdFromColor(next_color));

                    // If none is found creates a new province and gets the iterator.
                    if (next_prov_it == provincesInGeneration.end())
                        next_prov_it = createProvince(x,y + 1);

                    if((*prov_it).second.numeric_id < (*next_prov_it).second.numeric_id)
                        adjacencies.insert(std::make_pair((*prov_it).second.numeric_id,(*next_prov_it).second.numeric_id));
                    else
                        adjacencies.insert(std::make_pair((*next_prov_it).second.numeric_id,(*prov_it).second.numeric_id));

                    updateEdgeCoordinates(x, y + 1, next_prov_it);

                }       

            }
        }
    }

    fprintf(stdout, ">> Done analysing %u pixels and generating %lu provinces!\n", map_size.x * map_size.y, provincesInGeneration.size());
    fprintf(stdout, ">> Saving data to files...\n");
    fflush(stdout);

    // Saves province data to files.
    fprintf(stdout, ">>> Saving %s...\n", PROVINCES_TXT_PATH);
    FILE* province_file = fopen(PROVINCES_TXT_PATH,"w+");
    for(std::map <unsigned, mdata::Province>::iterator i = provincesInGeneration.begin(); i != provincesInGeneration.end(); i++) {

        (*i).second.generateCenter();
        fprintf(province_file, "%u %u %u %u %u %u\n", 
                (*i).second.numeric_id, (*i).second.color.r, (*i).second.color.g, (*i).second.color.b, (*i).second.center.x, (*i).second.center.y);
        
    }

    fclose(province_file);

    fprintf(stdout, ">>> Saving %s...\n", ADJACENCIES_TXT_PATH);
    FILE* adjacencies_file = fopen(ADJACENCIES_TXT_PATH,"w+");

    for(std::set<std::pair<unsigned, unsigned>>::iterator i = adjacencies.begin(); i != adjacencies.end(); i++) {

        fprintf(adjacencies_file, "%u %u\n", (*i).first, (*i).second);
        
    }

    fclose(adjacencies_file);

    return true;

}

bool mdata::MapGenerator::loadNecessaryFiles() {

    // Attempts to load the provinces.png image;
    fprintf(stdout, ">> Loading files...\n");
    fprintf(stdout, ">>> Loading %s...\n", PROVINCES_BMP_PATH);
    fflush(stdout);

    if(!provinceMap.loadFromFile(PROVINCES_BMP_PATH)) { 
        fprintf(stderr, ">>> Failed to load %s!\n", PROVINCES_BMP_PATH);
        return false; 
    }

    return true;

}

// Create a new province.
std::map <unsigned, mdata::Province>::iterator mdata::MapGenerator::createProvince(unsigned x, unsigned y) {

    Province new_province;
    new_province.numeric_id = provincesInGeneration.size();
    new_province.color = provinceMap.getPixel(x,y);

    // Return an iterator to the province.
    return provincesInGeneration.insert(std::make_pair(generateIdFromColor(new_province.color), new_province)).first;

}

// Update edge coordinates of a province that will later be used to find it's center.
void mdata::MapGenerator::updateEdgeCoordinates(unsigned x, unsigned y, std::map<unsigned,mdata::Province>::iterator prov_it) {

    if((*prov_it).second.min_x > x) { (*prov_it).second.min_x = x; }
    if((*prov_it).second.max_x < x) { (*prov_it).second.max_x = x; }
    if((*prov_it).second.min_y > y) { (*prov_it).second.min_y = y; }
    if((*prov_it).second.max_y < y) { (*prov_it).second.max_y = y; }

}

// Generates an unique number from a color RGB value that can be used as a key for a map.
unsigned mdata::MapGenerator::generateIdFromColor(sf::Color col) { 
    return 1000000 * col.r + 1000 * col.g + col.b; 
}